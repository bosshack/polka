# vim: set ft=sh sw=2 ts=2 expandtab:

remove_from_path() {
  case "$PATH" in
    *:"$1":*) PATH="$(echo "$PATH"|sed -e "s#:${1}##g")"
  esac
  export PATH
}

prepend_path() {
  local args arg dir

  # reverse the order of the arguments to preserve the order passed in
  for arg in $@; do
    args="$arg $args"
  done

  for dir in $args; do
    remove_from_path "$dir"
    PATH="${dir}:${PATH}"
  done
  export PATH
}

append_path() {
  local dir

  for dir in $@; do
    remove_from_path "$dir"
    PATH="${PATH}:${dir}"
  done
  export PATH
}

# git_prompt_info accepts 0 or 1 arguments (i.e., format string)
# returns text to add to bash PS1 prompt (includes branch name)
git_prompt_info () {
  local g="$(git rev-parse --git-dir 2>/dev/null)"
  if [ -n "$g" ]; then
    local r
    local b
    local d
    local s
    # Rebasing
    if [ -d "$g/rebase-apply" ] ; then
      if test -f "$g/rebase-apply/rebasing" ; then
        r="|REBASE"
      fi
      b="$(git symbolic-ref HEAD 2>/dev/null)"
    # Interactive rebase
    elif [ -f "$g/rebase-merge/interactive" ] ; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    # Merging
    elif [ -f "$g/MERGE_HEAD" ] ; then
      r="|MERGING"
      b="$(git symbolic-ref HEAD 2>/dev/null)"
    else
      if [ -f "$g/BISECT_LOG" ] ; then
        r="|BISECTING"
      fi
      if ! b="$(git symbolic-ref HEAD 2>/dev/null)" ; then
        if ! b="$(git describe --exact-match HEAD 2>/dev/null)" ; then
          b="$(cut -c1-7 "$g/HEAD")..."
        fi
      fi
    fi

    # Dirty Branch
    local newfile='?? '
    if [ -n "$ZSH_VERSION" ]; then
      newfile='\?\? '
    fi
    d=''
    s=$(git status --porcelain 2> /dev/null)
    [[ $s =~ "$newfile" ]] && d+="\033[0;32m+\033[00m"
    [[ $s =~ "M " ]] && d+="\033[0;33m*\033[00m"
    [[ $s =~ "D " ]] && d+="\033[0;31m-\033[00m"

    if [ -n "${1-}" ]; then
      printf "$1" "${b##refs/heads/}$r$d"
    else
      printf "(%b) " "${b##refs/heads/}$r$d"
    fi
  fi
}
